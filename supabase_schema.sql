-- Enable RLS
create table if not exists rate_limits (
  fingerprint text not null,
  window_start timestamp with time zone not null,
  request_count int not null default 1,
  primary key (fingerprint, window_start)
);

alter table rate_limits enable row level security;

-- Insert policies
CREATE POLICY "Users can insert their own lab results" ON lab_results
FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can insert their own biomarkers" ON biomarkers
FOR INSERT WITH CHECK (auth.uid() = user_id);
-- Create policy to deny all access by default (Service Role will bypass this)
create policy "Deny all access" on rate_limits for all using (false);

-- Deterministic Rate Limit Check
create or replace function check_rate_limit(
  p_fingerprint text,
  p_window_seconds int,
  p_limit int
) returns boolean as $$
declare
  current_window_start timestamp with time zone;
  current_count int;
begin
  -- Calculate window start (deterministic based on epoch)
  current_window_start := to_timestamp(floor(extract(epoch from now()) / p_window_seconds) * p_window_seconds);

  -- Insert or Update logic
  insert into rate_limits (fingerprint, window_start, request_count)
  values (p_fingerprint, current_window_start, 1)
  on conflict (fingerprint, window_start)
  do update set request_count = rate_limits.request_count + 1
  returning request_count into current_count;

  -- Return true if within limit, false if exceeded
  return current_count <= p_limit;
end;
$$ language plpgsql security definer;

-- Grant execution to anon and authenticated roles
grant execute on function check_rate_limit(text, int, int) to anon, authenticated;

-- Profiles Table
create table if not exists profiles (
  id uuid not null primary key,
  updated_at timestamp with time zone,
  first_name text,
  last_name text,
  blood_type text,
  constraint id foreign key (id) references auth.users (id) on delete cascade
);

alter table profiles enable row level security;
create policy "Users can view their own profile" on profiles for select using (auth.uid() = id);
create policy "Users can insert their own profile" on profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile" on profiles for update using (auth.uid() = id);

-- Lab Results Table
create table if not exists lab_results (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  health_score int,
  risk_level text,
  summary text
);

alter table lab_results enable row level security;
create policy "Users can view their own lab results" on lab_results for select using (auth.uid() = user_id);

-- Biomarkers Table
create table if not exists biomarkers (
  id bigint generated by default as identity primary key,
  lab_result_id bigint not null references lab_results(id) on delete cascade,
  name text,
  value float,
  unit text,
  status text,
  reference_range_min float,
  reference_range_max float,
  ai_interpretation text
);

alter table biomarkers enable row level security;
create policy "Users can view their own biomarkers" on biomarkers for select using (
  exists (
    select 1 from lab_results where lab_results.id = biomarkers.lab_result_id and lab_results.user_id = auth.uid()
  )
);

-- Symptoms Table
create table if not exists symptoms (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  symptom_text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table symptoms enable row level security;

-- Updates for Honesty Audit & Schema mismatch fix

-- Add missing columns to lab_results
ALTER TABLE lab_results
ADD COLUMN IF NOT EXISTS file_name text,
ADD COLUMN IF NOT EXISTS processed boolean DEFAULT false,
ADD COLUMN IF NOT EXISTS processing_time_ms integer;

-- Add missing columns to biomarkers
ALTER TABLE biomarkers
ADD COLUMN IF NOT EXISTS user_id uuid REFERENCES profiles(id) ON DELETE CASCADE,
ADD COLUMN IF NOT EXISTS category text,
ADD COLUMN IF NOT EXISTS confidence numeric,
ADD COLUMN IF NOT EXISTS reference_range_min numeric,
ADD COLUMN IF NOT EXISTS reference_range_max numeric;

-- Drop old misnamed columns if they exist
ALTER TABLE biomarkers
DROP COLUMN IF EXISTS reference_min,
DROP COLUMN IF EXISTS reference_max;

-- Update RLS policy for biomarkers
DROP POLICY IF EXISTS "Users see own biomarkers" ON biomarkers;

CREATE POLICY "Users see own biomarkers" ON biomarkers
FOR ALL USING (auth.uid() = user_id);

-- Atomic Save Function
CREATE OR REPLACE FUNCTION save_complete_report(
  p_user_id UUID,
  p_file_name TEXT,
  p_health_score INT,
  p_risk_level TEXT,
  p_summary TEXT,
  p_biomarkers JSONB
) RETURNS BIGINT AS $$
DECLARE
  v_report_id BIGINT;
BEGIN
  -- 1. Insert into lab_results
  INSERT INTO lab_results (
    user_id, 
    file_name, 
    health_score, 
    risk_level, 
    summary, 
    processed
  )
  VALUES (
    p_user_id, 
    p_file_name, 
    p_health_score, 
    p_risk_level, 
    p_summary, 
    true
  )
  RETURNING id INTO v_report_id;

  -- 2. Insert biomarkers from JSONB array
  INSERT INTO biomarkers (
    user_id, 
    lab_result_id, 
    name, 
    value, 
    unit, 
    status, 
    reference_range_min, 
    reference_range_max, 
    category, 
    confidence, 
    ai_interpretation
  )
  SELECT 
    p_user_id,
    v_report_id,
    (b->>'name')::TEXT,
    (b->>'value')::FLOAT,
    (b->>'unit')::TEXT,
    (b->>'status')::TEXT,
    (b->>'referenceMin')::FLOAT,
    (b->>'referenceMax')::FLOAT,
    (b->>'category')::TEXT,
    (b->>'confidence')::FLOAT,
    (b->>'aiInterpretation')::TEXT
  FROM jsonb_array_elements(p_biomarkers) AS b;

  RETURN v_report_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Updates for Technical Trace (adding raw data storage)
ALTER TABLE lab_results 
ADD COLUMN IF NOT EXISTS raw_ocr_text TEXT,
ADD COLUMN IF NOT EXISTS raw_ai_json JSONB;

-- Updated Save Function with raw data support
CREATE OR REPLACE FUNCTION save_complete_report(
  p_user_id UUID,
  p_file_name TEXT,
  p_health_score INT,
  p_risk_level TEXT,
  p_summary TEXT,
  p_biomarkers JSONB,
  p_raw_ocr_text TEXT DEFAULT NULL,
  p_raw_ai_json JSONB DEFAULT NULL
) RETURNS BIGINT AS $$
DECLARE
  v_report_id BIGINT;
BEGIN
  -- 1. Insert into lab_results
  INSERT INTO lab_results (
    user_id, 
    file_name, 
    health_score, 
    risk_level, 
    summary, 
    processed,
    raw_ocr_text,
    raw_ai_json
  )
  VALUES (
    p_user_id, 
    p_file_name, 
    p_health_score, 
    p_risk_level, 
    p_summary, 
    true,
    p_raw_ocr_text,
    p_raw_ai_json
  )
  RETURNING id INTO v_report_id;

  -- 2. Insert biomarkers from JSONB array
  INSERT INTO biomarkers (
    user_id, 
    lab_result_id, 
    name, 
    value, 
    unit, 
    status, 
    reference_range_min, 
    reference_range_max, 
    category, 
    confidence, 
    ai_interpretation
  )
  SELECT 
    p_user_id,
    v_report_id,
    (b->>'name')::TEXT,
    (b->>'value')::FLOAT,
    (b->>'unit')::TEXT,
    (b->>'status')::TEXT,
    (b->>'referenceMin')::FLOAT,
    (b->>'referenceMax')::FLOAT,
    (b->>'category')::TEXT,
    (b->>'confidence')::FLOAT,
    (b->>'aiInterpretation')::TEXT
  FROM jsonb_array_elements(p_biomarkers) AS b;

  RETURN v_report_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create feedback table
CREATE TABLE IF NOT EXISTS feedback (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  message TEXT NOT NULL,
  url TEXT,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

ALTER TABLE feedback ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can insert feedback" ON feedback FOR INSERT WITH CHECK (true);

-- Grant execution to authenticated users
GRANT EXECUTE ON FUNCTION save_complete_report(UUID, TEXT, INT, TEXT, TEXT, JSONB, TEXT, JSONB) TO authenticated;

