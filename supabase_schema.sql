-- Enable RLS
create table if not exists rate_limits (
  fingerprint text not null,
  window_start timestamp with time zone not null,
  request_count int not null default 1,
  primary key (fingerprint, window_start)
);

alter table rate_limits enable row level security;

-- Create policy to deny all access by default (Service Role will bypass this)
create policy "Deny all access" on rate_limits for all using (false);

-- Deterministic Rate Limit Check
create or replace function check_rate_limit(
  p_fingerprint text,
  p_window_seconds int,
  p_limit int
) returns boolean as $$
declare
  current_window_start timestamp with time zone;
  current_count int;
begin
  -- Calculate window start (deterministic based on epoch)
  current_window_start := to_timestamp(floor(extract(epoch from now()) / p_window_seconds) * p_window_seconds);

  -- Insert or Update logic
  insert into rate_limits (fingerprint, window_start, request_count)
  values (p_fingerprint, current_window_start, 1)
  on conflict (fingerprint, window_start)
  do update set request_count = rate_limits.request_count + 1
  returning request_count into current_count;

  -- Return true if within limit, false if exceeded
  return current_count <= p_limit;
end;
$$ language plpgsql security definer;

-- Grant execution to anon and authenticated roles
grant execute on function check_rate_limit(text, int, int) to anon, authenticated;

-- Profiles Table
create table if not exists profiles (
  id uuid not null primary key,
  updated_at timestamp with time zone,
  first_name text,
  last_name text,
  blood_type text,
  constraint id foreign key (id) references auth.users (id) on delete cascade
);

alter table profiles enable row level security;
create policy "Users can view their own profile" on profiles for select using (auth.uid() = id);
create policy "Users can insert their own profile" on profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile" on profiles for update using (auth.uid() = id);

-- Lab Results Table
create table if not exists lab_results (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  health_score int,
  risk_level text,
  summary text
);

alter table lab_results enable row level security;
create policy "Users can view their own lab results" on lab_results for select using (auth.uid() = user_id);

-- Biomarkers Table
create table if not exists biomarkers (
  id bigint generated by default as identity primary key,
  lab_result_id bigint not null references lab_results(id) on delete cascade,
  name text,
  value float,
  unit text,
  status text,
  reference_range_min float,
  reference_range_max float,
  ai_interpretation text
);

alter table biomarkers enable row level security;
create policy "Users can view their own biomarkers" on biomarkers for select using (
  exists (
    select 1 from lab_results where lab_results.id = biomarkers.lab_result_id and lab_results.user_id = auth.uid()
  )
);

-- Symptoms Table
create table if not exists symptoms (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  symptom_text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table symptoms enable row level security;
create policy "Users can manage their own symptoms" on symptoms for all using (auth.uid() = user_id);

