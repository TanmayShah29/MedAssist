-- Enable RLS
create table if not exists rate_limits (
  fingerprint text not null,
  window_start timestamp with time zone not null,
  request_count int not null default 1,
  primary key (fingerprint, window_start)
);

alter table rate_limits enable row level security;

-- Rate Limits Policies
DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Deny all access" ON rate_limits;
END $$;
create policy "Deny all access" on rate_limits for all using (false);

-- Deterministic Rate Limit Check
create or replace function check_rate_limit(
  p_fingerprint text,
  p_window_seconds int,
  p_limit int
) returns boolean as $$
declare
  current_window_start timestamp with time zone;
  current_count int;
begin
  -- Calculate window start (deterministic based on epoch)
  current_window_start := to_timestamp(floor(extract(epoch from now()) / p_window_seconds) * p_window_seconds);

  -- Insert or Update logic
  insert into rate_limits (fingerprint, window_start, request_count)
  values (p_fingerprint, current_window_start, 1)
  on conflict (fingerprint, window_start)
  do update set request_count = rate_limits.request_count + 1
  returning request_count into current_count;

  -- Return true if within limit, false if exceeded
  return current_count <= p_limit;
end;
$$ language plpgsql security definer;

-- Grant execution to anon and authenticated roles
grant execute on function check_rate_limit(text, int, int) to anon, authenticated;

-- Profiles Table
create table if not exists profiles (
  id uuid not null primary key,
  updated_at timestamp with time zone,
  first_name text,
  last_name text,
  blood_type text,
  onboarding_complete boolean default false,
  constraint id foreign key (id) references auth.users (id) on delete cascade
);

alter table profiles enable row level security;

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can view their own profile" ON profiles;
    DROP POLICY IF EXISTS "Users can insert their own profile" ON profiles;
    DROP POLICY IF EXISTS "Users can update their own profile" ON profiles;
END $$;

create policy "Users can view their own profile" on profiles for select using (auth.uid() = id);
create policy "Users can insert their own profile" on profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile" on profiles for update using (auth.uid() = id);

-- Lab Results Table
create table if not exists lab_results (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  health_score int,
  risk_level text,
  summary text,
  file_name text,
  processed boolean default false,
  processing_time_ms integer,
  raw_ocr_text text,
  raw_ai_json jsonb
);

alter table lab_results enable row level security;

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can view their own lab results" ON lab_results;
    DROP POLICY IF EXISTS "Users can insert their own lab results" ON lab_results;
END $$;

create policy "Users can view their own lab results" on lab_results for select using (auth.uid() = user_id);
create policy "Users can insert their own lab results" on lab_results for insert with check (auth.uid() = user_id);

-- Biomarkers Table
create table if not exists biomarkers (
  id bigint generated by default as identity primary key,
  lab_result_id bigint not null references lab_results(id) on delete cascade,
  user_id uuid references profiles(id) on delete cascade,
  name text,
  value float,
  unit text,
  status text,
  reference_range_min float,
  reference_range_max float,
  category text,
  confidence numeric,
  ai_interpretation text
);

alter table biomarkers enable row level security;

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can view their own biomarkers" ON biomarkers;
    DROP POLICY IF EXISTS "Users can insert their own biomarkers" ON biomarkers;
    DROP POLICY IF EXISTS "Users see own biomarkers" ON biomarkers;
END $$;

create policy "Users see own biomarkers" on biomarkers for all using (auth.uid() = user_id);

-- Symptoms Table
create table if not exists symptoms (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  symptom_text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table symptoms enable row level security;

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can manage their own symptoms" ON symptoms;
END $$;

CREATE POLICY "Users can manage their own symptoms" ON symptoms FOR ALL USING (auth.uid() = user_id);

-- Feedback Table
CREATE TABLE IF NOT EXISTS feedback (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  message TEXT NOT NULL,
  url TEXT,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

alter table feedback enable row level security;

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can insert feedback" ON feedback;
END $$;

CREATE POLICY "Users can insert feedback" ON feedback FOR INSERT WITH CHECK (true);

-- Supplements Table
CREATE TABLE IF NOT EXISTS supplements (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  dosage TEXT,
  frequency TEXT,
  start_date DATE NOT NULL,
  end_date DATE,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, now()) NOT NULL
);

alter table supplements enable row level security;

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can manage their own supplements" ON supplements;
END $$;

CREATE POLICY "Users can manage their own supplements" ON supplements FOR ALL USING (auth.uid() = user_id);

-- Updated Save Function with raw data support
CREATE OR REPLACE FUNCTION save_complete_report(
  p_user_id UUID,
  p_file_name TEXT,
  p_health_score INT,
  p_risk_level TEXT,
  p_summary TEXT,
  p_biomarkers JSONB,
  p_raw_ocr_text TEXT DEFAULT NULL,
  p_raw_ai_json JSONB DEFAULT NULL
) RETURNS BIGINT AS $$
DECLARE
  v_report_id BIGINT;
BEGIN
  -- 1. Insert into lab_results
  INSERT INTO lab_results (
    user_id, 
    file_name, 
    health_score, 
    risk_level, 
    summary, 
    processed,
    raw_ocr_text,
    raw_ai_json
  )
  VALUES (
    p_user_id, 
    p_file_name, 
    p_health_score, 
    p_risk_level, 
    p_summary, 
    true,
    p_raw_ocr_text,
    p_raw_ai_json
  )
  RETURNING id INTO v_report_id;

  -- 2. Insert biomarkers from JSONB array
  INSERT INTO biomarkers (
    user_id, 
    lab_result_id, 
    name, 
    value, 
    unit, 
    status, 
    reference_range_min, 
    reference_range_max, 
    category, 
    confidence, 
    ai_interpretation
  )
  SELECT 
    p_user_id,
    v_report_id,
    (b->>'name')::TEXT,
    (b->>'value')::FLOAT,
    (b->>'unit')::TEXT,
    (b->>'status')::TEXT,
    (b->>'referenceMin')::FLOAT,
    (b->>'referenceMax')::FLOAT,
    (b->>'category')::TEXT,
    (b->>'confidence')::FLOAT,
    (b->>'aiInterpretation')::TEXT
  FROM jsonb_array_elements(p_biomarkers) AS b;

  RETURN v_report_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execution to authenticated users
GRANT EXECUTE ON FUNCTION save_complete_report(UUID, TEXT, INT, TEXT, TEXT, JSONB, TEXT, JSONB) TO authenticated;
